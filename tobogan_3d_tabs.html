<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    // Cloth sim (bolsa) helpers
    const cloth = {
      resX: 30,
      resY: 30,
      points: [],
      prev: [],
      pinned: [],
      indices: null,
      geom: null,
      mesh: null,
      running: true
    };
    const clothWidthCache = { dx: 0, dz: 0 };

    function idx(u, v) { return v * cloth.resX + u; }

    function createClothMesh(width, height, overhang) {
      const dx = width / (cloth.resX - 1);
      const dz = height / (cloth.resY - 1);
      clothWidthCache.dx = dx;
      clothWidthCache.dz = dz;
      cloth.points = new Array(cloth.resX * cloth.resY);
      cloth.prev = new Array(cloth.resX * cloth.resY);
      cloth.pinned = new Array(cloth.resX * cloth.resY).fill(false);

      const startY = BIN_H + overhang + 100; // start above bin
      for (let v = 0; v < cloth.resY; v++) {
        for (let u = 0; u < cloth.resX; u++) {
          const x = -width/2 + u * dx;
          const z = -height/2 + v * dz;
          const y = startY - v * 5; // slight tilt to help settle
          const p = new THREE.Vector3(x, y, z);
          cloth.points[idx(u,v)] = p.clone();
          cloth.prev[idx(u,v)] = p.clone();
        }
      }

      // Pin a few outer corners to stabilize a bit
      cloth.pinned[idx(0,0)] = true;
      cloth.pinned[idx(cloth.resX-1,0)] = true;
      cloth.pinned[idx(0,cloth.resY-1)] = true;
      cloth.pinned[idx(cloth.resX-1,cloth.resY-1)] = true;

      // Geometry
      cloth.geom = new THREE.BufferGeometry();
      const positions = new Float32Array(cloth.points.length * 3);
      cloth.geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const indices = [];
      for (let v=0; v<cloth.resY-1; v++) {
        for (let u=0; u<cloth.resX-1; u++) {
          const a = idx(u, v);
          const b = idx(u+1, v);
          const c = idx(u, v+1);
          const d = idx(u+1, v+1);
          indices.push(a, c, b, b, c, d);
        }
      }
      cloth.indices = indices;
      cloth.geom.setIndex(indices);
      cloth.geom.computeVertexNormals();

      const bagMat = new THREE.MeshPhysicalMaterial({
        color: 0xe8f4ff,
        roughness: 0.75,
        metalness: 0,
        transparent: true,
        opacity: 0.42,
        transmission: 0.65,
        thickness: 1.5,
        ior: 1.02,
        side: THREE.DoubleSide
      });
      cloth.mesh = new THREE.Mesh(cloth.geom, bagMat);
      cloth.mesh.castShadow = false;
      cloth.mesh.receiveShadow = false;
      return cloth.mesh;
    }

    function satisfyConstraints(iterations, rest) {
      for (let it=0; it<iterations; it++) {
        for (let v=0; v<cloth.resY; v++) {
          for (let u=0; u<cloth.resX; u++) {
            const i = idx(u,v);
            const p = cloth.points[i];
            // vecinos estructurales
            if (u < cloth.resX-1) {
              const j = idx(u+1,v); project(p, cloth.points[j], rest.dx);
            }
            if (v < cloth.resY-1) {
              const j = idx(u,v+1); project(p, cloth.points[j], rest.dz);
            }
          }
        }
      }
    }

    function project(p1, p2, restLen) {
      const delta = new THREE.Vector3().subVectors(p2, p1);
      const dist = delta.length();
      if (!dist) return;
      const diff = (dist - restLen) / dist;
      const corr = delta.multiplyScalar(0.5 * diff);
      p1.add(corr);
      p2.sub(corr);
    }

    function applyForces(dt) {
      const gravity = new THREE.Vector3(0, -980, 0);
      const damp = 0.995;
      const dt2 = dt*dt;
      for (let i=0; i<cloth.points.length; i++) {
        if (cloth.pinned[i]) continue;
        const p = cloth.points[i];
        const prev = cloth.prev[i];
        const vel = new THREE.Vector3().subVectors(p, prev).multiplyScalar(damp);
        const next = new THREE.Vector3().addVectors(p, vel).addScaledVector(gravity, dt2);
        cloth.prev[i] = p.clone();
        cloth.points[i] = next;
      }
    }

    function collideBin() {
      const innerX = BIN_W/2 - BIN_THK * 0.6;
      const innerZ = BIN_L/2 - BIN_THK * 0.6;
      const innerY = BIN_H - 5;
      const outerX = BIN_W/2 + 40;
      const outerZ = BIN_L/2 + 40;
      const cuffY = BIN_H + 400; // limit cuff height

      for (let i=0; i<cloth.points.length; i++) {
        const p = cloth.points[i];
        // region test
        const insideFootprint = Math.abs(p.x) <= innerX && Math.abs(p.z) <= innerZ;
        if (insideFootprint && p.y < innerY) {
          p.x = Math.max(-innerX, Math.min(innerX, p.x));
          p.z = Math.max(-innerZ, Math.min(innerZ, p.z));
          p.y = Math.max(BIN_THK * 0.6, p.y);
        } else {
          // outside footprint -> cuff
          p.x = Math.max(-outerX, Math.min(outerX, p.x));
          p.z = Math.max(-outerZ, Math.min(outerZ, p.z));
          p.y = Math.min(cuffY, p.y);
          // let cuff hang: don't push up unless below rim
          if (p.y < BIN_H - 40) p.y = BIN_H - 40;
        }
      }
    }

    function updateGeometry() {
      const pos = cloth.geom.getAttribute('position');
      for (let i=0; i<cloth.points.length; i++) {
        const p = cloth.points[i];
        pos.setXYZ(i, p.x, p.y, p.z);
      }
      pos.needsUpdate = true;
      cloth.geom.computeVertexNormals();
    }

    function stepCloth(dt, rest) {
      if (!cloth.running) return;
      applyForces(dt);
      satisfyConstraints(10, rest);
      collideBin();
      updateGeometry();
    }

    function createBinPlaceholder() {
      const g = new THREE.Group();
      const bodyColor = 0x1f66d8;
      const matBody = new THREE.MeshStandardMaterial({
        color: bodyColor,
        roughness: 0.55,
        metalness: 0.05,
        transparent: true,
        opacity: 0.95,
        transmission: 0.03
      });
      const matDetail = new THREE.MeshStandardMaterial({ color: 0x104caa, roughness: 0.6, metalness: 0.05 });
      const overlap = 10; // solape para evitar fugas en uniones

      // Base con cantos redondeados
      const base = new THREE.Mesh(new RoundedBoxGeometry(BIN_W, BIN_THK, BIN_L, 4, BIN_THK*0.5), matBody);
      base.position.y = BIN_THK/2;
      base.castShadow = true; base.receiveShadow = true;
      g.add(base);

      // Paredes laterales huecas (sin tapa) con bordes achaflanados
      const wallSideGeom = new RoundedBoxGeometry(BIN_THK, BIN_H, BIN_L - 2*BIN_THK + 2*overlap, 4, BIN_THK*0.45);
      const wallFrontGeom = new RoundedBoxGeometry(BIN_W - 2*BIN_THK + 2*overlap, BIN_H, BIN_THK, 4, BIN_THK*0.45);

      const wallL = new THREE.Mesh(wallSideGeom, matBody);
      wallL.position.set(-BIN_W/2 + BIN_THK/2, BIN_THK/2 + BIN_H/2, 0);
      const wallR = wallL.clone(); wallR.position.x = BIN_W/2 - BIN_THK/2;
      const wallF = new THREE.Mesh(wallFrontGeom, matBody);
      wallF.position.set(0, BIN_THK/2 + BIN_H/2, BIN_L/2 - BIN_THK/2);
      const wallB = wallF.clone(); wallB.position.z = -BIN_L/2 + BIN_THK/2;
      [wallL, wallR, wallF, wallB].forEach(w => { w.castShadow = true; w.receiveShadow = true; g.add(w); });

      // Relleno de esquinas para sellar uniones
      const cornerGeom = new RoundedBoxGeometry(BIN_THK + overlap, BIN_H, BIN_THK + overlap, 4, BIN_THK*0.35);
      const corners = [
        { x:-BIN_W/2 + BIN_THK/2, z:-BIN_L/2 + BIN_THK/2 },
        { x:-BIN_W/2 + BIN_THK/2, z: BIN_L/2 - BIN_THK/2 },
        { x: BIN_W/2 - BIN_THK/2, z:-BIN_L/2 + BIN_THK/2 },
        { x: BIN_W/2 - BIN_THK/2, z: BIN_L/2 - BIN_THK/2 }
      ];
      corners.forEach(c => {
        const corner = new THREE.Mesh(cornerGeom, matBody);
        corner.position.set(c.x, BIN_THK/2 + BIN_H/2, c.z);
        corner.castShadow = true; corner.receiveShadow = true;
        g.add(corner);
      });

      // Pies tipo pallet
      const footGeom = new THREE.BoxGeometry(BIN_W/3 - 40, 120, BIN_L/2);
      [ -BIN_W/3, 0, BIN_W/3 ].forEach(x => {
        const foot = new THREE.Mesh(footGeom, matDetail);
        foot.position.set(x, 60, 0);
        foot.castShadow = true; foot.receiveShadow = true;
        g.add(foot);
      });

      // Bolsa con cloth
      const overhang = 350;
      const clothWidth = BIN_W + overhang*1.2;
      const clothDepth = BIN_L + overhang*1.2;
      const bagMesh = createClothMesh(clothWidth, clothDepth, overhang);
      g.add(bagMesh);

      g.position.set(BIN_POS_X, 0, BIN_POS_Z);
      return g;
    }
      wallGroup.add(wallFrontRight);
    }

    if (topHeight > 0) {
      const wallFrontTop = buildWallPanels(DOOR_W, topHeight, WALL_THK, 'x');
      wallFrontTop.position.set(-ROOM_W/2 + DOOR_OFFSET_FROM_LEFT + DOOR_W/2, DOOR_H + topHeight/2, frontZ);
      wallGroup.add(wallFrontTop);
    }

    scene.add(wallGroup);

    // Techo removido para vista abierta

    // Etiquetas numéricas en paredes
    function makeLabel(text) {
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0,0,size,size);
      ctx.fillStyle = '#e2e8f0';
      ctx.font = 'bold 140px Segoe UI';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(text, size/2, size/2);
      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = 8;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: true });
      const spr = new THREE.Sprite(mat);
      spr.scale.set(600, 600, 1);
      return spr;
    }

    const labelLeft = makeLabel('1'); labelLeft.position.set(-ROOM_W/2 + WALL_THK + 20, ROOM_H/2, 0);
    const labelRight = makeLabel('2'); labelRight.position.set(ROOM_W/2 - WALL_THK - 20, ROOM_H/2, 0);
    const labelBack = makeLabel('3'); labelBack.position.set(0, ROOM_H/2, -ROOM_L/2 + WALL_THK + 20);
    const labelFront = makeLabel('4'); labelFront.position.set(0, ROOM_H/2, ROOM_L/2 - WALL_THK - 20);
    const labels = [labelLeft, labelRight, labelBack, labelFront];
    scene.add(...labels);

    // Bin azul estilo foto (placeholder hueco). Se reemplaza si existe bin_model.glb
    const BIN_W = 1200, BIN_L = 1000, BIN_H = 900;
    const BIN_THK = 35;
    const BIN_POS_X = ROOM_W/2 - WALL_THK - BIN_W/2 - 100; // hacia pared 2 con margen
    const BIN_POS_Z = ROOM_L/2 - WALL_THK - BIN_L/2 - 700; // a 700 mm de la pared 4
    let binPlaceholder;

    function createBinPlaceholder() {
      const g = new THREE.Group();
      const bodyColor = 0x1f66d8;
      const matBody = new THREE.MeshStandardMaterial({
        color: bodyColor,
        roughness: 0.55,
        metalness: 0.05,
        transparent: true,
        opacity: 0.95,
        transmission: 0.03
      });
      const matDetail = new THREE.MeshStandardMaterial({ color: 0x104caa, roughness: 0.6, metalness: 0.05 });
      const overlap = 10; // solape para evitar fugas en uniones

      // Base con cantos redondeados
      const base = new THREE.Mesh(new RoundedBoxGeometry(BIN_W, BIN_THK, BIN_L, 4, BIN_THK*0.5), matBody);
      base.position.y = BIN_THK/2;
      base.castShadow = true; base.receiveShadow = true;
      g.add(base);

      // Paredes laterales huecas (sin tapa) con bordes achaflanados
      const wallSideGeom = new RoundedBoxGeometry(BIN_THK, BIN_H, BIN_L - 2*BIN_THK + 2*overlap, 4, BIN_THK*0.45);
      const wallFrontGeom = new RoundedBoxGeometry(BIN_W - 2*BIN_THK + 2*overlap, BIN_H, BIN_THK, 4, BIN_THK*0.45);

      const wallL = new THREE.Mesh(wallSideGeom, matBody);
      wallL.position.set(-BIN_W/2 + BIN_THK/2, BIN_THK/2 + BIN_H/2, 0);
      const wallR = wallL.clone(); wallR.position.x = BIN_W/2 - BIN_THK/2;
      const wallF = new THREE.Mesh(wallFrontGeom, matBody);
      wallF.position.set(0, BIN_THK/2 + BIN_H/2, BIN_L/2 - BIN_THK/2);
      const wallB = wallF.clone(); wallB.position.z = -BIN_L/2 + BIN_THK/2;
      [wallL, wallR, wallF, wallB].forEach(w => { w.castShadow = true; w.receiveShadow = true; g.add(w); });

      // Relleno de esquinas para sellar uniones
      const cornerGeom = new RoundedBoxGeometry(BIN_THK + overlap, BIN_H, BIN_THK + overlap, 4, BIN_THK*0.35);
      const corners = [
        { x:-BIN_W/2 + BIN_THK/2, z:-BIN_L/2 + BIN_THK/2 },
        { x:-BIN_W/2 + BIN_THK/2, z: BIN_L/2 - BIN_THK/2 },
        { x: BIN_W/2 - BIN_THK/2, z:-BIN_L/2 + BIN_THK/2 },
        { x: BIN_W/2 - BIN_THK/2, z: BIN_L/2 - BIN_THK/2 }
      ];
      corners.forEach(c => {
        const corner = new THREE.Mesh(cornerGeom, matBody);
        corner.position.set(c.x, BIN_THK/2 + BIN_H/2, c.z);
        corner.castShadow = true; corner.receiveShadow = true;
        g.add(corner);
      });

      // Pies tipo pallet
      const footGeom = new THREE.BoxGeometry(BIN_W/3 - 40, 120, BIN_L/2);
      [ -BIN_W/3, 0, BIN_W/3 ].forEach(x => {
        const foot = new THREE.Mesh(footGeom, matDetail);
        foot.position.set(x, 60, 0);
        foot.castShadow = true; foot.receiveShadow = true;
        g.add(foot);
      });

      // Bolsa (liner) translúcida: cubre interior y cae por fuera (~350 mm de cuff)
      const BAG_W = BIN_W - 2*BIN_THK + 40; // un poco más ancha para abrazar el exterior
      const BAG_L = BIN_L - 2*BIN_THK + 40;
      const BAG_H = BIN_H + 350; // sobresale 350 mm para el doblez y caída exterior
      const bagGeom = new THREE.BoxGeometry(BAG_W, BAG_H, BAG_L, 6, 6, 6);
      const posAttr = bagGeom.getAttribute('position');
      for (let i = 0; i < posAttr.count; i++) {
        const x = posAttr.getX(i);
        const y = posAttr.getY(i);
        const z = posAttr.getZ(i);
        const k = 0.1;
        const noise = (Math.random() - 0.5) * k;
        let nx = x + x*noise;
        let ny = y + y*noise*1.35;
        let nz = z + z*noise;

        // doblar hacia afuera en la zona superior (cuff ~350 mm)
        const foldZone = 240; // mm de zona para el doblez
        const foldDrop = 260; // caída del cuff sobre la cara externa
        const foldStart = BAG_H/2 - foldZone;
        if (y > foldStart) {
          const t = (y - foldStart) / foldZone; // 0..1
          const flare = 0.085;
          nx *= 1 + flare * t;
          nz *= 1 + flare * t;
          ny -= foldDrop * t;
        }

        const topSag = Math.max(0, (y - BAG_H/4) / BAG_H);
        ny -= topSag * 26 * Math.random();

        // colisión simple contra el bin: dentro se clampa al hueco, fuera abraza el exterior
        const innerX = BIN_W/2 - BIN_THK*0.7;
        const innerZ = BIN_L/2 - BIN_THK*0.7;
        const outerX = BIN_W/2 + 25;
        const outerZ = BIN_L/2 + 25;

        if (ny <= BIN_H) {
          nx = Math.max(-innerX, Math.min(innerX, nx));
          nz = Math.max(-innerZ, Math.min(innerZ, nz));
          ny = Math.max(BIN_THK * 0.6, ny);
        } else {
          nx = Math.max(-outerX, Math.min(outerX, nx));
          nz = Math.max(-outerZ, Math.min(outerZ, nz));
          ny = Math.max(BIN_H - 5, ny);
        }

        posAttr.setXYZ(i, nx, ny, nz);
      }
      posAttr.needsUpdate = true;
      bagGeom.computeVertexNormals();
      const bagMat = new THREE.MeshPhysicalMaterial({
        color: 0xe8f4ff,
        roughness: 0.75,
        metalness: 0.0,
        transparent: true,
        opacity: 0.45,
        transmission: 0.6,
        thickness: 1.5,
        ior: 1.02,
        side: THREE.DoubleSide
      });
      const bag = new THREE.Mesh(bagGeom, bagMat);
      bag.position.set(0, BAG_H/2 + BIN_THK - 10, 0);
      bag.castShadow = false; bag.receiveShadow = false;
      g.add(bag);

      g.position.set(BIN_POS_X, 0, BIN_POS_Z);
      return g;
    }

    binPlaceholder = createBinPlaceholder();
    scene.add(binPlaceholder);

    // Toggle paneles
    let wallsVisible = true;
    document.getElementById('btn-toggle-walls').addEventListener('click', ()=>{
      wallsVisible = !wallsVisible;
      wallGroup.visible = wallsVisible;
      labels.forEach(l=> l.visible = wallsVisible);
      document.getElementById('btn-toggle-walls').textContent = wallsVisible ? 'Ocultar paneles' : 'Mostrar paneles';
    });

    // Intentar cargar bin_model.glb si existe
    (function cargarBinGLB() {
      const loader = new GLTFLoader();
      loader.load('bin_model.glb', gltf => {
        if (binPlaceholder) scene.remove(binPlaceholder);
        cloth.running = false; // detener cloth placeholder si se carga GLB real
        const obj = gltf.scene;
        obj.traverse(n => { if (n.isMesh) { n.castShadow = true; n.receiveShadow = true; } });
        obj.scale.set(1,1,1);
        obj.position.set(BIN_POS_X, 0, BIN_POS_Z);
        scene.add(obj);
      }, undefined, () => {
        // si falla, se queda el placeholder
      });
    })();

    let last = performance.now();
    function animate(){
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = Math.min(0.033, (now - last)/1000); // cap dt
      last = now;

      // Cloth step: rest lengths
      if (cloth.geom) {
        const rest = {
          dx: (clothWidthCache.dx),
          dz: (clothWidthCache.dz)
        };
        stepCloth(dt, rest);
      }

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', ()=>{
      const h = window.innerHeight - 40;
      camera.aspect = window.innerWidth / h;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, h);
    });
  </script>
</body>
</html>
